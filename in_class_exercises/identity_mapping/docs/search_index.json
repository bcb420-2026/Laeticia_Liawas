[["index.html", "worked Example Welcome", " worked Example Ruth Isserlin Welcome This mini-book introduces identifier mapping and walks through practical examples using GEO datasets: GSE233947 GSE119732 "],["what-is-identifier-mapping.html", "Chapter 1 What is identifier mapping? 1.1 Visual overview", " Chapter 1 What is identifier mapping? Identifier mapping is translating between different ways of naming the same biological entity. Common situations: Data uses stable IDs (e.g., Ensembl gene IDs) Downstream tools want gene symbols (e.g., HGNC) Some assays use non-gene identifiers (probes, peptides, genomic coordinates) 1.1 Visual overview "],["getting-data-from-geo.html", "Chapter 2 Getting data from GEO", " Chapter 2 Getting data from GEO We download GEO supplementary files to obtain realistic identifiers. library(GEOquery) ## Loading required package: Biobase ## Loading required package: BiocGenerics ## Loading required package: generics ## ## Attaching package: &#39;generics&#39; ## The following objects are masked from &#39;package:base&#39;: ## ## as.difftime, as.factor, as.ordered, intersect, is.element, setdiff, ## setequal, union ## ## Attaching package: &#39;BiocGenerics&#39; ## The following objects are masked from &#39;package:stats&#39;: ## ## IQR, mad, sd, var, xtabs ## The following objects are masked from &#39;package:base&#39;: ## ## anyDuplicated, aperm, append, as.data.frame, basename, cbind, ## colnames, dirname, do.call, duplicated, eval, evalq, Filter, Find, ## get, grep, grepl, is.unsorted, lapply, Map, mapply, match, mget, ## order, paste, pmax, pmax.int, pmin, pmin.int, Position, rank, ## rbind, Reduce, rownames, sapply, saveRDS, table, tapply, unique, ## unsplit, which.max, which.min ## Welcome to Bioconductor ## ## Vignettes contain introductory material; view with ## &#39;browseVignettes()&#39;. To cite Bioconductor, see ## &#39;citation(&quot;Biobase&quot;)&#39;, and for packages &#39;citation(&quot;pkgname&quot;)&#39;. ## Setting options(&#39;download.file.method.GEOquery&#39;=&#39;auto&#39;) ## Setting options(&#39;GEOquery.inmemory.gpl&#39;=FALSE) source(&quot;./fetch_geo_supp.R&quot;) fetch_geo_supp(gse = &quot;GSE233947&quot;) ## Using locally cached version of supplementary file(s) GSE233947 found here: ## data/GSE233947/GSE233947_FeatureCounts_V31genes_RawCounts_ENSG.tsv.gz ## Using locally cached version of supplementary file(s) GSE233947 found here: ## data/GSE233947/GSE233947_modulize_3CTG_20CTG_junctions.tsv.gz ## Using locally cached version of supplementary file(s) GSE233947 found here: ## data/GSE233947/GSE233947_modulize_NT_20CTG_junctions.tsv.gz ## Using locally cached version of supplementary file(s) GSE233947 found here: ## data/GSE233947/GSE233947_modulize_NT_3CTG_junctions.tsv.gz fetch_geo_supp(gse = &quot;GSE119732&quot;) ## Using locally cached version of supplementary file(s) GSE119732 found here: ## data/GSE119732/GSE119732_count_table_RNA_seq.txt.gz "],["why-identifiers-are-messy.html", "Chapter 3 Why identifiers are messy", " Chapter 3 Why identifiers are messy Version suffixes: Ensembl IDs can appear as ENSG... .7 and often must be stripped. One-to-many mappings: a stable ID may map to multiple symbols (aliases/synonyms). Annotation drift: mappings depend on genome build and Ensembl/HGNC releases. Best practice: keep the stable ID as the key and add symbols as annotation columns. "],["biomart-step-by-step.html", "Chapter 4 biomaRt step-by-step 4.1 1. List marts 4.2 2. (Optional) pin an Ensembl archive version 4.3 3. List datasets and select human 4.4 4. Identify the correct filter 4.5 5. Identify the correct attributes 4.6 6. Strip version suffixes (if present) 4.7 7. Run the query with getBM() 4.8 8. Cache the mapping (recommended) 4.9 9. Merge back into your data", " Chapter 4 biomaRt step-by-step This follows the following workflow: choose a mart → choose a dataset → discover filters/attributes → query with getBM() → merge back into your matrix. library(biomaRt) 4.1 1. List marts listMarts() ## biomart version ## 1 ENSEMBL_MART_ENSEMBL Ensembl Genes 115 ## 2 ENSEMBL_MART_MOUSE Mouse strains 115 ## 3 ENSEMBL_MART_SNP Ensembl Variation 115 ## 4 ENSEMBL_MART_FUNCGEN Ensembl Regulation 115 4.2 2. (Optional) pin an Ensembl archive version listEnsemblArchives()[1:10,] ## name date url version ## 1 Ensembl GRCh37 Feb 2014 https://grch37.ensembl.org GRCh37 ## 2 Ensembl 115 Sep 2025 https://sep2025.archive.ensembl.org 115 ## 3 Ensembl 114 May 2025 https://may2025.archive.ensembl.org 114 ## 4 Ensembl 113 Oct 2024 https://oct2024.archive.ensembl.org 113 ## 5 Ensembl 112 May 2024 https://may2024.archive.ensembl.org 112 ## 6 Ensembl 111 Jan 2024 https://jan2024.archive.ensembl.org 111 ## 7 Ensembl 110 Jul 2023 https://jul2023.archive.ensembl.org 110 ## 8 Ensembl 109 Feb 2023 https://feb2023.archive.ensembl.org 109 ## 9 Ensembl 108 Oct 2022 https://oct2022.archive.ensembl.org 108 ## 10 Ensembl 107 Jul 2022 https://jul2022.archive.ensembl.org 107 ## current_release ## 1 ## 2 * ## 3 ## 4 ## 5 ## 6 ## 7 ## 8 ## 9 ## 10 # Example: pin to Ensembl 114 ensembl &lt;- useEnsembl(biomart = &quot;ensembl&quot;,version = params$ensembl_version) If you do not pin versions: ensembl &lt;- useMart(&quot;ensembl&quot;) 4.3 3. List datasets and select human datasets &lt;- listDatasets(ensembl) # filter for human human &lt;- datasets[grep(datasets$dataset, pattern = &quot;hsapiens&quot;), ] human ## dataset description version ## 80 hsapiens_gene_ensembl Human genes (GRCh38.p14) GRCh38.p14 ensembl &lt;- useDataset(&quot;hsapiens_gene_ensembl&quot;, mart = ensembl) 4.4 4. Identify the correct filter Filters are your input ID type. all_filters &lt;- listFilters(ensembl) dim(all_filters) ## [1] 443 2 # search for Ensembl gene filters all_filters[grep(all_filters$name, pattern = &quot;ensembl_gene&quot;), ] ## name ## 54 ensembl_gene_id ## 55 ensembl_gene_id_version ## description ## 54 Gene stable ID(s) [e.g. ENSG00000000003] ## 55 Gene stable ID(s) with version [e.g. ENSG00000000003.17] For Ensembl gene IDs, use filter: ensembl_gene_id. 4.5 5. Identify the correct attributes Attributes are the output columns you want. all_attr &lt;- listAttributes(ensembl) all_attr[1:10,] ## name description page ## 1 ensembl_gene_id Gene stable ID feature_page ## 2 ensembl_gene_id_version Gene stable ID version feature_page ## 3 ensembl_transcript_id Transcript stable ID feature_page ## 4 ensembl_transcript_id_version Transcript stable ID version feature_page ## 5 ensembl_peptide_id Protein stable ID feature_page ## 6 ensembl_peptide_id_version Protein stable ID version feature_page ## 7 ensembl_exon_id Exon stable ID feature_page ## 8 description Gene description feature_page ## 9 chromosome_name Chromosome/scaffold name feature_page ## 10 start_position Gene start (bp) feature_page # search for HGNC searchAttributes(ensembl, &quot;hgnc&quot;) ## name description page ## 63 hgnc_symbol HGNC symbol feature_page ## 64 hgnc_id HGNC ID feature_page ## 95 hgnc_trans_name Transcript name ID feature_page Common attributes: ensembl_gene_id hgnc_symbol 4.6 6. Strip version suffixes (if present) strip_ensembl_version &lt;- function(x) sub(&quot;\\\\..*$&quot;, &quot;&quot;, x) ids &lt;- c(&quot;ENSG00000141510.17&quot;, &quot;ENSG00000157764.2&quot;) ids_clean &lt;- strip_ensembl_version(ids) ids_clean ## [1] &quot;ENSG00000141510&quot; &quot;ENSG00000157764&quot; 4.7 7. Run the query with getBM() map &lt;- getBM( attributes = c(&quot;ensembl_gene_id&quot;, &quot;hgnc_symbol&quot;), filters = &quot;ensembl_gene_id&quot;, values = ids_clean, mart = ensembl ) map ## ensembl_gene_id hgnc_symbol ## 1 ENSG00000141510 TP53 ## 2 ENSG00000157764 BRAF 4.8 8. Cache the mapping (recommended) cache_file &lt;- &quot;id_conversion.rds&quot; if (file.exists(cache_file)) { map &lt;- readRDS(cache_file) } else { map &lt;- getBM( attributes = c(&quot;ensembl_gene_id&quot;, &quot;hgnc_symbol&quot;), filters = &quot;ensembl_gene_id&quot;, values = ids_clean, mart = ensembl ) saveRDS(map, cache_file) } 4.9 9. Merge back into your data library(dplyr) ## ## Attaching package: &#39;dplyr&#39; ## The following object is masked from &#39;package:biomaRt&#39;: ## ## select ## The following objects are masked from &#39;package:stats&#39;: ## ## filter, lag ## The following objects are masked from &#39;package:base&#39;: ## ## intersect, setdiff, setequal, union df &lt;- tibble(ensembl_gene_id = ids_clean, value = c(1, 2)) df_annot &lt;- left_join(df, map, by = &quot;ensembl_gene_id&quot;) df_annot ## # A tibble: 2 × 3 ## ensembl_gene_id value hgnc_symbol ## &lt;chr&gt; &lt;dbl&gt; &lt;chr&gt; ## 1 ENSG00000141510 1 TP53 ## 2 ENSG00000157764 2 BRAF "],["worked-examples-with-beforeafter-tables.html", "Chapter 5 Worked examples with before/after tables 5.1 GSE233947", " Chapter 5 Worked examples with before/after tables This chapter shows what the data look like, what the IDs look like, and how the table changes once mapped. library(knitr) library(dplyr) ## ## Attaching package: &#39;dplyr&#39; ## The following objects are masked from &#39;package:stats&#39;: ## ## filter, lag ## The following objects are masked from &#39;package:base&#39;: ## ## intersect, setdiff, setequal, union library(tibble) kable_head &lt;- function(x, n = 5, caption = NULL) { knitr::kable(utils::head(x, n), caption = caption) } strip_ensembl_version &lt;- function(x) sub(&quot;\\\\..*$&quot;, &quot;&quot;, x) 5.1 GSE233947 5.1.1 Raw data preview source(&quot;./fetch_geo_supp.R&quot;) fetch_geo_supp(gse = params$gse) ## Setting options(&#39;download.file.method.GEOquery&#39;=&#39;auto&#39;) ## Setting options(&#39;GEOquery.inmemory.gpl&#39;=FALSE) ## Using locally cached version of supplementary file(s) GSE233947 found here: ## data/GSE233947/GSE233947_FeatureCounts_V31genes_RawCounts_ENSG.tsv.gz ## Using locally cached version of supplementary file(s) GSE233947 found here: ## data/GSE233947/GSE233947_modulize_3CTG_20CTG_junctions.tsv.gz ## Using locally cached version of supplementary file(s) GSE233947 found here: ## data/GSE233947/GSE233947_modulize_NT_20CTG_junctions.tsv.gz ## Using locally cached version of supplementary file(s) GSE233947 found here: ## data/GSE233947/GSE233947_modulize_NT_3CTG_junctions.tsv.gz path &lt;- file.path(&quot;data&quot;, params$gse) files &lt;- list.files(path, pattern = params$file_grep, full.names = TRUE, recursive = TRUE) kable_head(tibble(file = basename(files)), min(10, length(files)), paste(params$gse,&quot;: extracted file list (first 10)&quot;)) (#tab:get_data)GSE233947 : extracted file list (first 10) file GSE233947_FeatureCounts_V31genes_RawCounts_ENSG.tsv.gz GSE233947_modulize_3CTG_20CTG_junctions.tsv.gz GSE233947_modulize_NT_20CTG_junctions.tsv.gz GSE233947_modulize_NT_3CTG_junctions.tsv.gz Raw table preview library(readr) safe_read &lt;- function(file) { # First attempt: read as TSV df &lt;- tryCatch( readr::read_tsv(file, show_col_types = FALSE), error = function(e) NULL # catch fatal errors ) # If read_tsv failed entirely: if (is.null(df)) { message(&quot;TSV read failed — reading as space-delimited file instead.&quot;) return(readr::read_table(file, show_col_types = FALSE)) } # If read_tsv returned but with parsing issues: probs &lt;- problems(df) if (nrow(probs) &gt; 0) { message(&quot;Parsing issues detected in TSV — reading as space-delimited file instead.&quot;) return(readr::read_table(file, show_col_types = FALSE)) } # If everything was fine: return(df) } x &lt;- safe_read(files[1]) kable_head(x[, 1:min(6, ncol(x))], 5, paste(params$gse,&quot;: raw table preview&quot;)) (#tab:preview_raw)GSE233947 : raw table preview Gene T8657_900CTG_NT T8658_1150CTG_NT T8659_1450CTG_NT T8660_900CTG_20CTG T8661_1150CTG_20CTG ENSG00000108821 456397 486088 608151 2012962 379186 ENSG00000265150 170681 299425 286295 747000 210962 ENSG00000164692 169781 190854 263391 869194 180006 ENSG00000265735 78113 121697 113379 532435 112977 ENSG00000259001 55081 78811 73032 353442 100823 ID preview id_col &lt;- names(x)[1] ids &lt;- x[[1]] |&gt; as.character() kable_head(tibble(raw_id = head(ids, 10), stripped = strip_ensembl_version(head(ids, 10))), 10, paste(params$gse,&quot;: ID preview&quot;)) (#tab:id_preview)GSE233947 : ID preview raw_id stripped ENSG00000108821 ENSG00000108821 ENSG00000265150 ENSG00000265150 ENSG00000164692 ENSG00000164692 ENSG00000265735 ENSG00000265735 ENSG00000259001 ENSG00000259001 ENSG00000163359 ENSG00000163359 ENSG00000115414 ENSG00000115414 ENSG00000168542 ENSG00000168542 ENSG00000251562 ENSG00000251562 ENSG00000155657 ENSG00000155657 5.1.2 After mapping (Ensembl → HGNC) if (any(grepl(&quot;^ENSG&quot;, strip_ensembl_version(ids)))) { library(biomaRt) ensembl_ids &lt;- unique(strip_ensembl_version(ids)) ensembl &lt;- useMart(&quot;ensembl&quot;, dataset = &quot;hsapiens_gene_ensembl&quot;) map &lt;- getBM( attributes = c(&quot;ensembl_gene_id&quot;, &quot;hgnc_symbol&quot;), filters = &quot;ensembl_gene_id&quot;, values = ensembl_ids, mart = ensembl ) kable_head(map, 10, paste(params$gse,&quot;: mapping preview&quot;)) expr_mapped &lt;- x %&gt;% mutate(ensembl_gene_id = strip_ensembl_version(.data[[id_col]])) %&gt;% left_join(map, by = &quot;ensembl_gene_id&quot;) %&gt;% dplyr::select( ensembl_gene_id,hgnc_symbol, everything()) kable_head(expr_mapped[, 1:min(8, ncol(expr_mapped))], 5, paste(params$gse,&quot;: mapped table preview&quot;)) } (#tab:after_map)GSE233947 : mapped table preview ensembl_gene_id hgnc_symbol Gene T8657_900CTG_NT T8658_1150CTG_NT T8659_1450CTG_NT T8660_900CTG_20CTG T8661_1150CTG_20CTG ENSG00000108821 COL1A1 ENSG00000108821 456397 486088 608151 2012962 379186 ENSG00000265150 NA ENSG00000265150 170681 299425 286295 747000 210962 ENSG00000164692 COL1A2 ENSG00000164692 169781 190854 263391 869194 180006 ENSG00000265735 RN7SL5P ENSG00000265735 78113 121697 113379 532435 112977 ENSG00000259001 ENSG00000259001 55081 78811 73032 353442 100823 Summarize the mapping n_ensembl_total &lt;- expr_mapped %&gt;% distinct(ensembl_gene_id) %&gt;% nrow() n_mapped &lt;- expr_mapped %&gt;% filter(!is.na(hgnc_symbol), hgnc_symbol != &quot;&quot;) %&gt;% distinct(ensembl_gene_id) %&gt;% nrow() n_unmapped &lt;- n_ensembl_total - n_mapped mapping_summary &lt;- tibble::tibble( category = c(&quot;Total Ensembl IDs&quot;, &quot;Mapped to HGNC&quot;, &quot;Unmapped&quot;), n = c(n_ensembl_total, n_mapped, n_unmapped) ) mapping_summary ## # A tibble: 3 × 2 ## category n ## &lt;chr&gt; &lt;int&gt; ## 1 Total Ensembl IDs 62248 ## 2 Mapped to HGNC 40176 ## 3 Unmapped 22072 unmapped_ids &lt;- expr_mapped %&gt;% distinct(ensembl_gene_id, hgnc_symbol) %&gt;% filter(is.na(hgnc_symbol) | hgnc_symbol == &quot;&quot;) %&gt;% pull(ensembl_gene_id) %&gt;% unique() length(unmapped_ids) ## [1] 22072 library(stringr) unmapped_classified &lt;- tibble::tibble(id = unmapped_ids) %&gt;% mutate(type = case_when( str_detect(id, &quot;^ENSG\\\\d+$&quot;) ~ &quot;Ensembl gene ID (ENSG)&quot;, str_detect(id, &quot;^ENSG\\\\d+\\\\.\\\\d+$&quot;) ~ &quot;Ensembl gene ID with version (ENSG.x) — needs stripping&quot;, str_detect(id, &quot;^ENST\\\\d+&quot;) ~ &quot;Ensembl transcript ID (ENST) — wrong target for gene mapping&quot;, str_detect(id, &quot;^ENSP\\\\d+&quot;) ~ &quot;Ensembl protein ID (ENSP) — wrong target&quot;, str_detect(id, &quot;^ENS.*G\\\\d+&quot;) ~ &quot;Non-human Ensembl gene (e.g., ENSMUSG...) — wrong organism&quot;, str_detect(id, &quot;^ERCC-&quot;) ~ &quot;ERCC spike-in control — not a gene&quot;, str_detect(id, &quot;^MT-|^mt-&quot;) ~ &quot;Mitochondrial gene symbol (not Ensembl ID) — different ID system&quot;, str_detect(id, &quot;^\\\\d+$&quot;) ~ &quot;Entrez Gene ID — different ID system&quot;, TRUE ~ &quot;Other / unknown format&quot; )) unmapped_classified %&gt;% count(type) %&gt;% arrange(desc(n)) ## # A tibble: 1 × 2 ## type n ## &lt;chr&gt; &lt;int&gt; ## 1 Ensembl gene ID (ENSG) 22072 # Use the same mart/dataset as your mapping step: # ensembl &lt;- useMart(&quot;ensembl&quot;, dataset = &quot;hsapiens_gene_ensembl&quot;) ensg_details &lt;- getBM( attributes = c( &quot;ensembl_gene_id&quot;, &quot;gene_biotype&quot;, &quot;external_gene_name&quot; ), filters = &quot;ensembl_gene_id&quot;, values = unmapped_ids, mart = ensembl ) head(ensg_details) ## ensembl_gene_id gene_biotype external_gene_name ## 1 ENSG00000093100 lncRNA ## 2 ENSG00000124593 protein_coding ## 3 ENSG00000124835 lncRNA ## 4 ENSG00000141979 protein_coding ## 5 ENSG00000149656 transcribed_unprocessed_pseudogene ## 6 ENSG00000151303 lncRNA Output the distribution of biotypes for the subset of ensembl ids that have no HGNC ID. library(ggplot2) x &lt;- ensg_details$gene_biotype x[is.na(x)] &lt;- &quot;Unknown&quot; # Base R counts table -&gt; data.frame tab &lt;- table(x) df_counts &lt;- data.frame( biotype = names(tab), n = as.integer(tab), stringsAsFactors = FALSE ) # Order by counts (ascending) for a nice horizontal bar chart df_counts &lt;- df_counts[order(df_counts$n,decreasing = TRUE), ] df_counts$biotype &lt;- factor(df_counts$biotype, levels = df_counts$biotype) #only include the top 20 biotypes df_counts &lt;- df_counts[1:min(10, nrow(df_counts)), ] ggplot(df_counts, aes(x = biotype, y = n, fill = biotype)) + geom_col(width = 0.8, color = &quot;grey20&quot;) + coord_flip() + scale_fill_brewer(palette = &quot;Set3&quot;, guide = &quot;none&quot;) + labs( x = NULL, y = &quot;Number of genes&quot;, title = &quot;Distribution of Gene Biotypes - \\ntop 10 types not mapped&quot; ) + theme_minimal(base_size = 13) + theme( plot.title.position = &quot;plot&quot;, panel.grid.major.y = element_blank() ) Would the mapping of these identifiers have been different if we used a different version of Ensembl? -&gt; I think that there is the potential for them to be different, because there could have been a change or an update that would lead to some of the identifiers to map differently. "],["exercises.html", "Chapter 6 Exercises 6.1 Exercise 1 — https://www.ncbi.nlm.nih.gov/geo/query/acc.cgi?acc=GSE119732 6.2 Exercise 2 — https://www.ncbi.nlm.nih.gov/geo/query/acc.cgi?acc=GSE122380 6.3 Exercise 3 -", " Chapter 6 Exercises These are intended to be done after completing the worked examples. 6.1 Exercise 1 — https://www.ncbi.nlm.nih.gov/geo/query/acc.cgi?acc=GSE119732 Using GSE119732, confirm whether the ID column contains Ensembl IDs with version suffixes. Extract the first 20 IDs. First, we extract the raw data files from the GSE. source(&quot;fetch_geo_supp.R&quot;) library(dplyr) ## ## Attaching package: &#39;dplyr&#39; ## The following objects are masked from &#39;package:stats&#39;: ## ## filter, lag ## The following objects are masked from &#39;package:base&#39;: ## ## intersect, setdiff, setequal, union library(GEOquery) ## Loading required package: Biobase ## Loading required package: BiocGenerics ## Loading required package: generics ## ## Attaching package: &#39;generics&#39; ## The following object is masked from &#39;package:dplyr&#39;: ## ## explain ## The following objects are masked from &#39;package:base&#39;: ## ## as.difftime, as.factor, as.ordered, intersect, is.element, setdiff, ## setequal, union ## ## Attaching package: &#39;BiocGenerics&#39; ## The following object is masked from &#39;package:dplyr&#39;: ## ## combine ## The following objects are masked from &#39;package:stats&#39;: ## ## IQR, mad, sd, var, xtabs ## The following objects are masked from &#39;package:base&#39;: ## ## anyDuplicated, aperm, append, as.data.frame, basename, cbind, ## colnames, dirname, do.call, duplicated, eval, evalq, Filter, Find, ## get, grep, grepl, is.unsorted, lapply, Map, mapply, match, mget, ## order, paste, pmax, pmax.int, pmin, pmin.int, Position, rank, ## rbind, Reduce, rownames, sapply, saveRDS, table, tapply, unique, ## unsplit, which.max, which.min ## Welcome to Bioconductor ## ## Vignettes contain introductory material; view with ## &#39;browseVignettes()&#39;. To cite Bioconductor, see ## &#39;citation(&quot;Biobase&quot;)&#39;, and for packages &#39;citation(&quot;pkgname&quot;)&#39;. ## Setting options(&#39;download.file.method.GEOquery&#39;=&#39;auto&#39;) ## Setting options(&#39;GEOquery.inmemory.gpl&#39;=FALSE) library(biomaRt) gse1 &lt;- &quot;GSE119732&quot; # get GSE, then get files in the GSE file_grep &lt;- &quot;\\\\.txt.gz$|\\\\.tsv.gz$|\\\\.csv.gz$&quot; fetch_geo_supp(gse1) ## Using locally cached version of supplementary file(s) GSE119732 found here: ## data/GSE119732/GSE119732_count_table_RNA_seq.txt.gz gse1_path &lt;- file.path(&quot;data&quot;, gse1) gse1_files &lt;- list.files(gse1_path, pattern = file_grep, full.names = TRUE, recursive = TRUE) cat(gse1_files, sep = &quot;\\n&quot;) ## data/GSE119732/GSE119732_count_table_RNA_seq.txt.gz From here, we see that there is only one file, a .txt file of RNA counts. We can then extract the first 20 IDs in this file. # Read the first 20 lines of the text file. Preview how it looks to see if need # to make any changes. gse1_data &lt;- read.table(gse1_files, header = T) rmarkdown::paged_table(gse1_data[seq(1, 20, by = 1),]) The data table looks right, so we read in the data using the read.table() function, using these arguments. The first 20 IDs are as yielded above. Count how many contain a .. We use grep() to find the indices in which gene_id has .: gse1_versioned &lt;- grep(&#39;\\\\.&#39;, gse1_data$gene_id) sprintf(&quot;Number of IDs with `.`: %s&quot;, length(gse1_versioned)) ## [1] &quot;Number of IDs with `.`: 58037&quot; sprintf(&quot;Number of IDs (total): %s&quot;, nrow(gse1_data)) ## [1] &quot;Number of IDs (total): 58037&quot; It seems that all of them have ., i.e. all of them have version numbers. Create a new column with versions stripped. We use gsub() to replace the . and anything after it with \"\". gse1_unversioned &lt;- gsub(&quot;\\\\..*&quot;, &quot;&quot;, gse1_data$gene_id) # sanity check paste(gse1_data[1,1], gse1_unversioned[1]) ## [1] &quot;ENSG00000223972.5 ENSG00000223972&quot; # create a new column in the original table, move it beside the OG gene_id gse1_data$gene_id_unversioned &lt;- gse1_unversioned gse1_data &lt;- gse1_data %&gt;% relocate(gene_id_unversioned, .after = gene_id) Map the identifiers to HGNC symbols. # attributes we want: ENSG to HGNC # Attribute names from 04-biomart-step-by-step ensembl &lt;- useMart( biomart = &quot;ensembl&quot;, dataset = &quot;hsapiens_gene_ensembl&quot; ) gse1_mapping &lt;- getBM(attributes = c(&quot;ensembl_gene_id&quot;, &quot;hgnc_symbol&quot;), filters = &quot;ensembl_gene_id&quot;, value = gse1_data$gene_id_unversioned, mart = ensembl) # cant use mutate() because of potential missing values # use left_join() gse1_data_annot &lt;- left_join( gse1_data, gse1_mapping, by = c(&quot;gene_id_unversioned&quot; = &quot;ensembl_gene_id&quot;) ) ## Warning in left_join(gse1_data, gse1_mapping, by = c(gene_id_unversioned = &quot;ensembl_gene_id&quot;)): Detected an unexpected many-to-many relationship between `x` and `y`. ## ℹ Row 29117 of `x` matches multiple rows in `y`. ## ℹ Row 53996 of `y` matches multiple rows in `x`. ## ℹ If a many-to-many relationship is expected, set `relationship = ## &quot;many-to-many&quot;` to silence this warning. gse1_data_annot &lt;- gse1_data_annot %&gt;% relocate(hgnc_symbol, .after = gene_id_unversioned) # sanity check gse1_data_annot[1,] ## gene_id gene_id_unversioned hgnc_symbol A1 A2 A3 A4 B1 B2 B3 B4 B5 ## 1 ENSG00000223972.5 ENSG00000223972 DDX11L1 0 0 0 0 0 0 0 0 0 ## C1 C2 C3 C4 C5 D1 D2 D3 D4 D5 E1 E2 E3 E4 E5 F1 F2 F3 F4 F5 ## 1 1 0 0 0 0 0 0 0 0 0 0 1 0 0 0 0 0 0 0 0 6.2 Exercise 2 — https://www.ncbi.nlm.nih.gov/geo/query/acc.cgi?acc=GSE122380 Using GSE122380, confirm whether the ID column contains Ensembl IDs with version suffixes. Extract the first 20 IDs. Same as before, but replace the GSE accession number. gse2 &lt;- &quot;GSE122380&quot; # get GSE, then get files in the GSE file_grep = &quot;\\\\.txt.gz$|\\\\.tsv.gz$|\\\\.csv.gz$&quot; fetch_geo_supp(gse2) ## Using locally cached version of supplementary file(s) GSE122380 found here: ## data/GSE122380/GSE122380_Supplementary_Data_Table_S1.xlsx ## Using locally cached version of supplementary file(s) GSE122380 found here: ## data/GSE122380/GSE122380_raw_counts.txt.gz gse2_path &lt;- file.path(&quot;data&quot;, gse2) gse2_files &lt;- list.files(gse2_path, pattern = file_grep, full.names = TRUE, recursive = TRUE) cat(gse2_files, sep = &quot;, &quot;) ## data/GSE122380/GSE122380_raw_counts.txt.gz Next, read the file. # Read the first 20 lines of the text file. Preview how it looks to see if need # to make any changes. gse2_data &lt;- read.table(gse2_files, header = T) rmarkdown::paged_table(gse2_data[seq(1, 20, by = 1),]) Create a new column with versions stripped. The first 20 IDs have no version number, so we need to be a bit more careful. Conditionally substitute, so that if there is no gene number, keep it constant. gse2_data &lt;- gse2_data %&gt;% mutate(Gene_id = gsub(&quot;\\\\..*&quot;, &quot;&quot;, Gene_id)) # sanity check paste(gse2_data[seq(1, 10, by = 1),1]) ## [1] &quot;ENSG00000000419&quot; &quot;ENSG00000000457&quot; &quot;ENSG00000000460&quot; &quot;ENSG00000000938&quot; ## [5] &quot;ENSG00000000971&quot; &quot;ENSG00000001036&quot; &quot;ENSG00000001084&quot; &quot;ENSG00000001167&quot; ## [9] &quot;ENSG00000001460&quot; &quot;ENSG00000001461&quot; Map the identifiers to HGNC symbols. # attributes we want: ENSG to HGNC # Attribute names from 04-biomart-step-by-step gse2_mapping &lt;- getBM(attributes = c(&quot;ensembl_gene_id&quot;, &quot;hgnc_symbol&quot;), filters = &quot;ensembl_gene_id&quot;, value = gse2_data$Gene_id, mart = ensembl) # cant use mutate() because of potential missing values # use left_join() gse2_data_annot &lt;- left_join(gse2_data, gse2_mapping, by = join_by(Gene_id == ensembl_gene_id)) gse2_data_annot &lt;- gse2_data_annot %&gt;% relocate(hgnc_symbol, .after = Gene_id) # sanity check gse2_data_annot[1,] ## Gene_id hgnc_symbol X18489_0 X18489_10 X18489_11 X18489_12 X18489_13 ## 1 ENSG00000000419 DPM1 825 549 576 599 607 ## X18489_14 X18489_15 X18489_1 X18489_2 X18489_3 X18489_4 X18489_5 X18489_6 ## 1 582 589 2432 1044 874 766 632 839 ## X18489_7 X18489_8 X18489_9 X18499_0 X18499_10 X18499_11 X18499_12 X18499_13 ## 1 685 640 636 1130 1294 1400 1184 1395 ## X18499_14 X18499_15 X18499_1 X18499_2 X18499_3 X18499_4 X18499_5 X18499_6 ## 1 1357 1592 2435 1563 2341 1200 1477 1558 ## X18499_7 X18499_8 X18499_9 X18505_0 X18505_10 X18505_11 X18505_12 X18505_13 ## 1 1208 1234 1419 1111 702 935 725 1096 ## X18505_14 X18505_15 X18505_1 X18505_2 X18505_3 X18505_4 X18505_5 X18505_6 ## 1 819 751 3518 1821 1575 1464 1225 1240 ## X18505_7 X18505_8 X18505_9 X18508_0 X18508_10 X18508_11 X18508_12 X18508_13 ## 1 795 798 840 709 554 650 501 599 ## X18508_14 X18508_15 X18508_1 X18508_2 X18508_3 X18508_4 X18508_5 X18508_6 ## 1 561 585 2234 1153 908 839 785 703 ## X18508_7 X18508_8 X18508_9 X18511_0 X18511_10 X18511_11 X18511_12 X18511_13 ## 1 591 597 743 1152 1057 908 1069 887 ## X18511_14 X18511_15 X18511_1 X18511_2 X18511_3 X18511_4 X18511_5 X18511_6 ## 1 1001 864 2593 1490 1391 1516 1289 1413 ## X18511_7 X18511_8 X18511_9 X18517_0 X18517_10 X18517_11 X18517_12 X18517_13 ## 1 1008 1117 929 627 587 612 636 640 ## X18517_14 X18517_15 X18517_1 X18517_2 X18517_3 X18517_4 X18517_5 X18517_6 ## 1 657 582 1563 865 804 977 868 922 ## X18517_7 X18517_8 X18517_9 X18520_0 X18520_10 X18520_11 X18520_12 X18520_13 ## 1 728 691 556 957 861 793 928 845 ## X18520_14 X18520_15 X18520_1 X18520_3 X18520_4 X18520_5 X18520_6 X18520_7 ## 1 1039 907 2053 1176 1112 1061 937 917 ## X18520_8 X18520_9 X18855_0 X18855_10 X18855_11 X18855_12 X18855_13 X18855_14 ## 1 904 842 1057 987 1619 749 1334 979 ## X18855_15 X18855_1 X18855_3 X18855_4 X18855_5 X18855_6 X18855_7 X18855_8 ## 1 1530 3598 2504 1011 1751 951 1415 981 ## X18855_9 X18858_0 X18858_10 X18858_11 X18858_12 X18858_13 X18858_14 X18858_15 ## 1 1448 1052 1496 1408 1528 1421 1319 1278 ## X18858_1 X18858_2 X18858_3 X18858_4 X18858_5 X18858_6 X18858_7 X18858_8 ## 1 3854 1686 1610 1953 1901 1762 1472 1474 ## X18858_9 X18870_0 X18870_10 X18870_11 X18870_12 X18870_13 X18870_14 X18870_15 ## 1 1573 1194 833 839 586 651 617 581 ## X18870_1 X18870_2 X18870_3 X18870_5 X18870_6 X18870_7 X18870_8 X18870_9 ## 1 2523 1311 953 589 718 729 831 724 ## X18907_0 X18907_10 X18907_11 X18907_12 X18907_13 X18907_14 X18907_15 X18907_1 ## 1 680 603 748 571 597 572 577 1756 ## X18907_2 X18907_3 X18907_4 X18907_5 X18907_6 X18907_7 X18907_8 X18907_9 ## 1 1160 806 847 871 824 722 787 727 ## X18912_0 X18912_10 X18912_11 X18912_12 X18912_13 X18912_14 X18912_15 X18912_1 ## 1 960 838 743 737 750 661 431 3810 ## X18912_2 X18912_3 X18912_4 X18912_5 X18912_6 X18912_7 X18912_8 X18912_9 ## 1 1417 1227 1068 1070 938 781 670 789 ## X19093_0 X19093_10 X19093_11 X19093_12 X19093_13 X19093_14 X19093_15 X19093_1 ## 1 702 781 943 727 1060 820 956 3404 ## X19093_2 X19093_3 X19093_4 X19093_5 X19093_6 X19093_7 X19093_8 X19093_9 ## 1 874 1037 802 856 866 731 699 1037 ## X19108_0 X19108_10 X19108_11 X19108_12 X19108_13 X19108_14 X19108_15 X19108_1 ## 1 1067 753 764 777 702 769 556 2143 ## X19108_2 X19108_3 X19108_5 X19108_6 X19108_7 X19108_8 X19108_9 X19127_0 ## 1 1178 991 699 1171 1091 981 655 658 ## X19127_10 X19127_11 X19127_12 X19127_13 X19127_14 X19127_15 X19127_1 X19127_2 ## 1 892 791 853 939 884 691 2008 1173 ## X19127_3 X19127_4 X19127_5 X19127_6 X19127_7 X19127_8 X19127_9 X19159_0 ## 1 1091 890 635 910 900 739 972 842 ## X19159_10 X19159_11 X19159_12 X19159_13 X19159_14 X19159_15 X19159_1 X19159_2 ## 1 709 894 688 602 584 4691 2322 1007 ## X19159_3 X19159_4 X19159_5 X19159_6 X19159_7 X19159_8 X19159_9 X19190_0 ## 1 958 703 718 802 4126 779 962 550 ## X19190_10 X19190_11 X19190_12 X19190_13 X19190_14 X19190_15 X19190_1 X19190_2 ## 1 514 861 582 586 625 524 1586 816 ## X19190_3 X19190_4 X19190_5 X19190_6 X19190_7 X19190_8 X19190_9 X19193_0 ## 1 625 822 925 754 532 735 546 900 ## X19193_10 X19193_11 X19193_12 X19193_13 X19193_14 X19193_15 X19193_1 X19193_2 ## 1 881 912 911 820 819 719 1593 1233 ## X19193_3 X19193_5 X19193_6 X19193_7 X19193_8 X19193_9 X19209_0 X19209_10 ## 1 929 870 1096 811 1005 725 842 665 ## X19209_11 X19209_12 X19209_14 X19209_15 X19209_1 X19209_3 X19209_4 X19209_5 ## 1 771 726 821 789 1835 1070 974 907 ## X19209_6 X19209_7 X19209_8 X19209_9 ## 1 746 988 747 755 What is different about this file? In this file, the gene IDs are mostly unversioned. So, it is important to check what we are working with before doing anything. 6.3 Exercise 3 - Can you use the worked example to process the above two GEO records? How? You can, by replacing the param$gse value, as well as changing some steps, e.g. change the method of file reading because the file types are different (.tsv vs .txt). "],["404.html", "Page not found", " Page not found The page you requested cannot be found (perhaps it was moved or renamed). You may want to try searching to find the page's new location, or use the table of contents to find the page you are looking for. "]]
